#include <iostream>
#include <string>

// Тестовая функция на С++ для сравнения результатов с ассемблерной вставкой

void Test(unsigned short* X,unsigned int SIZE) {
    unsigned short* EDX = &X[0];
    unsigned short* ESI = &X[0];

    int CX = SIZE;
    CX--;
    while (CX != 0) {
        ESI += 1;
        if (*ESI < *EDX) EDX = ESI;
        CX--;
    }
    printf("C++: %hu %p", *EDX, EDX);
}

void Zadanie_1() {
    //Вычислить 6 значений элементов последовательности an = (3^n) / (n + 5) (для n от 1 с шагом 1). Результат округлить до целого и раз-местить в памяти.

    #define COUNT 6

    unsigned short N = 1;                // Инициализация переменной последовательности
    unsigned short Rez[COUNT];           // Массив для записи 6 значений последовательности

    __asm {

        LEA ESI, Rez                     // Помещение адреса первого элемента массива в регистр ESI
        CIKL :                           // Метка цикла


            MOV CX, N                    // Помещение переменной в регистр СХ
            MOV AX, 1                    // Помещение единицы в регистр АХ, для начального значения степени
            MOV BX, 3                    // Помещение тройки в регистр ВХ
            STEPEN :                     // Метка цикла для вычисления числа в степени
                MUL BX                   // Возведение в степень тройки
                LOOP STEPEN              // Если счетчик не равен нулю, возвращаемся в тело цикла

            MOV BX, N                    // Помещаем значение переменной в регистр ВХ
            ADD BX, 5                    // Суммируем значение переменной с пятеркой

            DIV BX                       // Делим наше выражение


            MOV WORD PTR[ESI], AX        // Заносим результат в массив из регистра АХ
            ADD ESI, 2                   // Увеличиваем индекс элемента из массива

            ADD N, 1                     // Увеличиваем значение счетчика на 1
            CMP N, COUNT                 // Сравниваем счетчик с количеством необходимых итераций
            JNA CIKL                     // Если не больше, возращаемся в тело цикла
    };

    printf("1) ");

    for (unsigned short& x : Rez) {      // Вывод массива с результатами
        printf("%d ", x);
    }

    printf("\n");
    #undef COUNT
}

void Zadanie_2() {
    //Найти целое значение аргумента, при котором функция Y = 9 * x^2 – 8 * x + 15 станет больше 1000.
    #define CMP_VALUE 1000
    short X = 0;                         // Инициализация переменной

    __asm {

        CIKL :                           // Метка цикла


            MOV AX, 9                    // Помещаем 9 в регистр АХ
            MUL X                        // и умножаем на переменную в степени 2
            MUL X
            MOV BX, AX                   // Заносим результат в регистр ВХ

            MOV AX, 8                    // Помещаем 8 в регистр АХ
            MUL X                        // Умножаем на значение переменной
            SUB BX, AX                   // Вычитаем результаты и прибавляем 15
            ADD BX, 15



            CMP BX, CMP_VALUE            // Сравниваем значение функции с необходимым
            JA END                       // Если значение выше - выходим из цикла

            INC X                        // Если ниже - возвращаемся в тело цикла
            JMP CIKL
        END :                            // Метка выхода из цикла
    };

    printf("2) %d\n", X);

    #undef CMP_VALUE
}

void Zadanie_3() {
    //В памяти задан массив из 10 элементов.Поместить в регистр EAX минимальный элемент массива, а в регистр EDX его адрес в памяти.

    #define SIZE 10
    unsigned short X[SIZE];              // Обьявление массива из 10 элементов
    X[0] = SIZE * 17;                    // Инициализация первого элемента значением

    for (int i = 1; i < SIZE; i++) {     // Заполнение всего цикла значениеями
        X[i] = (X[i - 1] + 11) % 233;
    }


    unsigned int _EAX;                   // Инициализация переменных, для вывода результатов
    unsigned int* _EDX;

    __asm {
        LEA EDX, X                       // Помещение адреса первого элемента массива в регистр ЕDX, ESI
        LEA ESI, X
        MOV CX, SIZE                     // Помещение размера массива в регистр СХ и его декремент
        DEC CX
        

        CIKL :                           // Метка цикла
        
        ADD ESI, 2                       // Инкримент адреса, для перемещения по массиву
        MOV BX, WORD PTR[EDX]            // Помещение значения элемента массива в регистр ВХ
        CMP WORD PTR[ESI], BX            // Сравниваем 2 значения, чтобы найти меньший
        JNB DECR                         // Если не меньше, прыгаем в цикл декрементации
        MOV EDX, ESI                     // Если меньше, то помещаем значение в регистр EDX
        DECR:                            // Метка цикла
        MOV BX, CX                       // Помещение индекса в регистр ВХ и декремент СХ
        DEC CX
        JNZ CIKL                         // Если индекс не равен нулю, возвращаемся в тело цикла

        MOV EAX, DWORD PTR[EDX]          // Если равен, то выходим из цикла и заносим результаты в регистры

        MOV _EAX, EAX
        MOV _EDX, EDX
    };

                                         // Вывод результатов
    std::string Array;

    for (unsigned short& x : X) {       
        Array += std::to_string(x) + " ";
    }

    printf("3) %s\nAsm: %hu %p\n", Array.c_str(), _EAX, _EDX);

    Test(X, SIZE);                       // Вызов тестовой функции на С++
}

int main()
{

    Zadanie_1();                         // Вызов функций
    Zadanie_2();
    Zadanie_3();
    printf("\n");
    return 0;
}
